# 学び
- `fwrite()`は`malloc(0x3ff)`と`free()`を行う。
- `scanf`に`＋`を入れるとバッファを触らず処理が終わる。(令和CTFでも見せてもらった気がする)
- `printf`のformatにおける`%3$c`と`%3c`の違い。前者がスペース、後者がcharの取り出し。後者でnullを入れられる。
- 作問のポイントはcanaryを格納したポイントがlibcからの固定オフセットになっていること、とのこと。(そもそもリークがわからんかったので、本質まで行けてない。)

# 解き方
- 64bitを超える計算結果になると、オーバフローが発生。`fwrite()`と入力バッファの`free()`の順番が入れ替わる。
- 上記の順番が入れ替わった結果、`fwrite()`がとるheapメモリの位置と、入力バッファが次に確保するheapメモリの位置が重ならなくなる。
- 入力サイズを同様にすることで、そのサイズが0x420を超えていればmain_arenaの情報が計算結果に含まれる。ここまでがリーク。
- 出力はされないが、qを打った後、名前を入力するとコメントを求められる。このコメントは`sprintf()`にそのままその内容が飛ぶため、fsbが存在する。
- `%p`、`%s`などでバッファを伸ばすと、canaryを壊すので、その手前で上手くオフセットを合わせて`%XX$s`を仕込めばよい(`X`は数字が入る)
- ただし`%s`はnullが入らないため、canaryは+1したアドレスで7byteだけ入れる。nullは`%XX$c`で適当に拾ってきたら良い。
- 無事canaryを突破できたら、後は適当に文字を入れて、retの部分を調整してone_gadgetを積んで終わり。

ubuntu18.04でも19.04でも、オフセットが変わるだけで動いた。
