# Harekaze Note (Point:300, Solve:9)
初めてTcacheやっつけたので残す。  
## ポイント探し
オフセット見たらlibcは2.29っぽい。ubuntu19がんばって入れておいてよかった。  
走らせてスクリプト書きながらデコンパイルを眺める。  
主要関数は以下の通り。

---
### create
タイトルを聞いて入れる。サイズは0xfで後ろにnull強制。  
mallocは0x28で固定。個数は79個まで。  
初期化時に双方向リストのようなものを入れる。

### write
タイトルを聞いて、サイズを聞いて、コンテンツを書き込む。  
サイズは1から0x4fまで。後ろにnull強制。
mallocして、コンテンツへのポインタを張る。  
すでに値が存在すると書き込めない。

### show
タイトルを聞いて、一致するもののコンテンツを表示する。  
コンテンツにあるアドレスをそのままputsに投げ込んでいる。

### delete
タイトルを聞いて、一致するものを消す。  
双方向リストのポインタ付け替えを行う。  
コンテンツへのアドレスをfree、note構造体もfree  
**コンテンツへのアドレスは消さない。**

---
後ろがnull強制ということで、とりいそぎ文字埋めてつなぐ系はすべて阻まれた。  
コンテンツへのポインタの低位１バイトを変える方針で考えた。 
変え方はこんな感じ。

```
1. create("A")
2. write("A", 0x18, "a") 
3. create("B")
4. delete("A")
5. delete("B")
6. create("C")
7. write("C", 0x28, "c"*20) 
8. delete("C")
9. create("D")
10. create("E")
11. show("E")
```

2でAのnote構造体にコンテンツへのポインタが作られる。  
7でAのnote構造体だったところがコンテンツになるので、0x20個の文字で埋めると、コンテンツへのポインタが書き換わる。  
10で再びAのnote構造体だったところがEのnote構造体になるので、showによって改ざんされたところを表示することができる。

### exploitの作成
まず必要な情報とその理由は、
 - heapのベースアドレス：fastbin dupをやるため(なんだけど結局使わなかった)
 - libcアドレス：書き込むもの、書き込み先を知るため。

ヒープは双方向リストにあるので、どこかが漏れることを狙う。  
最初にいくつかnoteを作って、末尾が0x300になるところにfdが来るように調整する。  
コンテンツのアドレスの末尾が0x3X0になっているものに対して、上記のテクニックで書き換えてshowにつなげる。  

libcは、gotアドレスがランダムなのでわからないため、ワンクッション必要だった。  
双方向リストをよく見ていると、リストの一番先頭はコードセグメントのところにつながっている。（用語がわからん。語彙力定期）  
そのため、これをリークすると、オフセットは固定なのでlibcアドレスを持っているアドレス(gotとか)を知れる。  
幸いなことに、一度目でfdをリークできていれば、そのリストより前につながっているものをすべて削除すれば、このアドレスをリークさせることができる。

---

あとは書き込むだけ。この時点でsolve0だったし、あとやるだけんじゃん、FBごちｗって思ってたけど、double free出すぎて萎えて寝てしまった。起きたらめっちゃ解かれてた。  
とりあえず、落ち着いて2.29のTcacheの記事を探す。  
http://www.auxy.xyz/research/2018/11/22/TCache-Exp.html

はい、ありがたい。要するにtcache内ではどこ行ってもdouble free取られますよってこと。実際にfreeの処理追って見ても、一個ずつリスト確認しててだめだと言うことは見た。dupやりたかったら6個詰めたらいいらしい。  
こういうの書く側になりたいですね。

というわけで、今度は末尾が0x400になるところをコンテンツに持つnote構造体を2つ作って、dup作ってone_gadget放り込んでいくかたちにして終わり。  
最後one_gadgetを試しているときに、stack smashの表示が出ていたがどういう仕組みなんだろう。とても気になる。
